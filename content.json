{"meta":{"title":null,"subtitle":"","description":"","author":"hanzug","url":"https://hanzug.github.io","root":"/"},"pages":[{"title":"notes","date":"2022-07-18T01:02:32.000Z","updated":"2022-07-18T01:37:38.050Z","comments":true,"path":"categories/index.html","permalink":"https://hanzug.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-18T02:13:49.000Z","updated":"2022-07-18T02:23:11.950Z","comments":true,"path":"tags/index.html","permalink":"https://hanzug.github.io/tags/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-07-18T01:09:01.000Z","updated":"2022-07-18T01:09:01.228Z","comments":true,"path":"notes/index.html","permalink":"https://hanzug.github.io/notes/index.html","excerpt":"","text":""}],"posts":[{"title":"杭电杯 1003 Copy","slug":"Copy","date":"2022-07-22T07:44:34.739Z","updated":"2022-07-22T07:44:34.740Z","comments":true,"path":"2022/07/22/Copy/","link":"","permalink":"https://hanzug.github.io/2022/07/22/Copy/","excerpt":"","text":"题目 题意： 给定一个数组，两种操作： 1.给定 l， r 复制 l ~ r 内的数，插入到 r 后 2.询问数组中第 x 个数的值 求值的异或和。 思路 ： 由于求的是询问值的异或和，则考虑答案的表示形式， 数组中每个值是否询问到，可以考虑用 0 / 1 来表示，每次对数组的改变是区间的形式，则考虑bitset / 位运算 一个修改操作对后续查询操作的影响： 如果 x &lt;= r 没影响，如果 x &gt; r 则相当于查询 x - (r - l + 1). 可以考虑 bitset 位运算 令 $f[i]$ 表示答案需要对 $a[i]$ 异或。、 我们在倒序离线处理的过程中，每次可以 f 中的 1 转移到复制之前的位置。 123456789101112if(p[i].opt == 1)&#123; bitset&lt;N&gt; low, high; // bitset 一般都是从左开始往右看。 low = f &amp; (all &gt;&gt; (n - r)); // 截取 0 ~ r high = f &amp; (all &lt;&lt; (r)); // 截取 r + 1 ~ n f = low ^ (high &gt;&gt; (r - l + 1)); // 拼接新串(划掉) /* 将这之后的查询转移到复制前的串中 这就是反向离线查询的目的啊 */ &#125; else f.flip(l); code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const int N = 1e5 + 10;struct Q &#123; int opt, l, r;&#125;p[N];int n, q;int a[N];bitset&lt;N&gt; f, all;int main()&#123; int t; cin &gt;&gt; t; while(t -- )&#123; cin &gt;&gt; n &gt;&gt; q; for(int i = 1; i &lt;= n; i ++ )&#123; scanf(&quot;%d&quot;, a + i); &#125; for(int i = 1; i &lt;= q; i ++ )&#123; int op, l, r; cin &gt;&gt; op; if(op == 1)&#123; scanf(&quot;%d%d&quot;, &amp;l, &amp;r), p[i] = &#123;op, l, r&#125;; &#125; else &#123; cin &gt;&gt; l, p[i] = &#123;op, l, 0&#125;; &#125; &#125; all.reset(), f.reset(); for(int i = 1; i &lt;= n; i ++ )&#123; all[i] = 1; &#125; // all 是工具bitset， 用于 &amp; 截取需要的 bit 段 for(int i = q; i &gt;= 1; i -- )&#123; int l = p[i].l, r = p[i].r; if(p[i].opt == 1)&#123; bitset&lt;N&gt; low, high; // bitset 一般都是从左开始往右看。 low = f &amp; (all &gt;&gt; (n - r)); // 截取 0 ~ r high = f &amp; (all &lt;&lt; (r)); // 截取 r + 1 ~ n f = low ^ (high &gt;&gt; (r - l + 1)); // 拼接新串(划掉) /* 将这之后的查询转移到复制前的串中 这就是反向离线查询的目的啊 */ &#125; else f.flip(l); &#125; int ans = 0; for(int i = 1; i &lt;= n; i ++ )&#123; if(f[i]) ans ^= a[i]; &#125; printf(&quot;%d\\n&quot;, ans); &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"bitset","slug":"bitset","permalink":"https://hanzug.github.io/tags/bitset/"},{"name":"位运算","slug":"位运算","permalink":"https://hanzug.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"FFT 快速傅里叶变换","slug":"FFT，NNT","date":"2022-07-20T15:14:23.632Z","updated":"2022-07-22T07:51:44.560Z","comments":true,"path":"2022/07/20/FFT，NNT/","link":"","permalink":"https://hanzug.github.io/2022/07/20/FFT%EF%BC%8CNNT/","excerpt":"","text":"由于学的不是很细，且大佬的博客十分详细，绝大部分内容转载自大佬博客 前置知识 递归过程： 重点总结： 1.一个 n - 1 次多项式在 n 格不同点的取值唯一确定了该多项式。 2.由于复数的特殊性质（折半定理，消去定理），以复数的单位向量来作为点的取值 3.通过观察迭代过程，我们发现于原序列相比，实际递归需要用到的序列每个数于原序列的数的二进制相反 板子来了： 普通版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394const int N = 5000007;const double PI = acos(-1);int n, m;int res, ans[N];int limit = 1;//int L;//二进制的位数int R[N];inline int read()&#123; register int x = 0, f = 1; register char ch = getchar(); while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;) &#123;if(ch == &#x27;-&#x27;)f = -1;ch = getchar();&#125; while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) &#123;x = x * 10 + ch - &#x27;0&#x27;;ch = getchar();&#125; return x * f;&#125;struct Complex&#123; double x, y; Complex (double x = 0, double y = 0) : x(x), y(y) &#123; &#125;&#125;a[N], b[N];Complex operator * (Complex J, Complex Q) &#123; //模长相乘，幅度相加 return Complex(J.x * Q.x - J.y * Q.y, J.x * Q.y + J.y * Q.x);&#125;Complex operator - (Complex J, Complex Q) &#123; return Complex(J.x - Q.x, J.y - Q.y);&#125;Complex operator + (Complex J, Complex Q) &#123; return Complex(J.x + Q.x, J.y + Q.y);&#125;void FFT(Complex * A, int type)&#123; for(int i = 0; i &lt; limit; ++ i) if(i &lt; R[i]) swap(A[i], A[R[i]]); //i小于R[i]时才交换，防止同一个元素交换两次，回到它原来的位置。 //从底层往上合并 for(int mid = 1; mid &lt; limit; mid &lt;&lt;= 1) &#123; //待合并区间长度的一半，最开始是两个长度为1的序列合并,mid = 1; Complex wn(cos(PI / mid), type * sin(PI / mid));//单位根w_n^1; for(int len = mid &lt;&lt; 1, pos = 0; pos &lt; limit; pos += len) &#123; //len是区间的长度，pos是当前的位置,也就是合并到了哪一位 Complex w(1, 0);//幂,一直乘，得到平方，三次方... for(int k = 0; k &lt; mid; ++ k, w = w * wn) &#123; //只扫左半部分，蝴蝶变换得到右半部分的答案,w 为 w_n^k Complex x = A[pos + k];//左半部分 Complex y = w * A[pos + mid + k];//右半部分 A[pos + k] = x + y;//左边加 A[pos + mid + k] = x - y;//右边减 &#125; &#125; &#125; if(type == 1) return ; for(int i = 0; i &lt;= limit; ++ i) A[i].x /= limit; //最后要除以limit也就是补成了2的整数幂的那个N，将点值转换为系数 //（前面推过了点值与系数之间相除是N）&#125;int main()&#123; n = read(), m = read(); //读入多项式的每一项，保存在复数的实部 for(int i = 0; i &lt;= n; ++ i) a[i].x = read(); for(int i = 0; i &lt;= m; ++ i) b[i].x = read(); while(limit &lt;= n + m) limit &lt;&lt;= 1, L ++ ; //也可以写成：limit = 1 &lt;&lt; int(log2(n + m) + 1); // 补成2的整次幂，也就是N for(int i = 0; i &lt; limit; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); FFT(a, 1);//FFT 把a的系数表示转化为点值表示 FFT(b, 1);//FFT 把b的系数表示转化为点值表示 //计算两个系数表示法的多项式相乘后的点值表示 for(int i = 0; i &lt;= limit; ++ i) a[i] = a[i] * b[i]; //对应项相乘，O(n)得到点值表示的多项式的解C，利用逆变换完成插值得到答案C的点值表示 FFT(a, -1); for(int i = 0; i &lt;= n + m; ++ i) //这里的 x 和 y 是 double 的 hhh printf(&quot;%d &quot;, (int)(a[i].x + 0.5));//注意要+0.5，否则精度会有问题&#125; 优化版： 设 a 和 b 是 实多项式，F=a+bi 则 $F^2=a^2−b^2+2abi$，注意到我们要求的ab正是 F 虚部的一半。这样只需要两次FFT就可以求出结果。 所以我们可以把 b(x) 放到 a(x) 的虚部上去，求出$a(x)^2$，然后把 a(x) 的虚部取出来除 2 就是答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void FFT(Complex * A, int type)//FFT板子&#123; for(int i = 0; i &lt; limit; ++ i) if(i &lt; R[i]) swap(A[i], A[R[i]]); for(int mid = 1; mid &lt; limit; mid &lt;&lt;= 1) &#123; Complex wn(cos(PI / mid), type * sin(PI / mid)); for(int len = mid &lt;&lt; 1, pos = 0; pos &lt; limit; pos += len) &#123; Complex w(1, 0); for(int k = 0; k &lt; mid; ++ k, w = w * wn) &#123; Complex x = A[pos + k]; Complex y = w * A[pos + mid + k]; A[pos + k] = x + y; A[pos + mid + k] = x - y; &#125; &#125; &#125; if(type == 1) return ; for(int i = 0; i &lt;= limit; ++ i) a[i].x /= limit, a[i].y /= limit;&#125;int main()&#123; n = read(), m = read(); for(int i = 0; i &lt;= n; ++ i) a[i].x = read(); for(int i = 0; i &lt;= m; ++ i) a[i].y = read();//把b(x)放到a(x)的虚部上 while(limit &lt;= n + m) limit &lt;&lt;= 1, L ++ ; for(int i = 0; i &lt; limit; ++ i) R[i] = (R[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (L - 1)); FFT(a, 1); for(int i = 0; i &lt;= limit; ++ i) a[i] = a[i] * a[i];//求出a(x)^2 FFT(a, -1); for(int i = 0; i &lt;= n + m; ++ i) printf(&quot;%d &quot;, (int)(a[i].y / 2 + 0.5)); //虚部取出来除2，注意要+0.5，否则精度会有问题,这里的x和y都是double&#125; NTT 原根 $对于 g，p \\in Z, 如果 g^i\\ mod \\ p (1 &lt;= i &lt;= p - 1) 的值互不相同， 则称 g 为 p 的原根$ 没什么快速求法，只能暴力枚举， 但是： 通常的模数有 ：998244353 ,1004535809,469762049，这几个数的原根都是 3. NTT 板子： 123456789101112131415161718192021222324252627282930313233#define g 3 // 原根#define mod 998244353 // 通常状态下的模数int qmi(int x, int y)&#123; &#125;inline void ntt(int a[],int len,int inv)&#123; int bit=0; while ((1&lt;&lt;bit)&lt;len)++bit; fo(i,0,len-1) &#123; rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(bit-1)); if (i&lt;rev[i])swap(a[i],a[rev[i]]); &#125;//前面和FFT一样 for (int mid=1;mid&lt;len;mid*=2) &#123; int tmp=pow(g,(mod-1)/(mid*2));//原根代替单位根 if (inv==-1)tmp=pow(tmp,mod-2);//逆变换则乘上逆元 for (int i=0;i&lt;len;i+=mid*2) &#123; int omega=1; for (ll j=0;j&lt;mid;++j,omega=omega*tmp%mod) &#123; int x=a[i+j],y=omega*a[i+j+mid]%mod; a[i+j]=(x+y)%mod,a[i+j+mid]=(x-y+mod)%mod;//注意取模 &#125; &#125;//大体和FFT差不多 &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"BSGS","slug":"BSGS","date":"2022-07-20T10:12:35.117Z","updated":"2022-07-20T10:15:40.932Z","comments":true,"path":"2022/07/20/BSGS/","link":"","permalink":"https://hanzug.github.io/2022/07/20/BSGS/","excerpt":"","text":"普通BSGS 适用问题： 给定正整数，$a, b, p, 且a与p互质$ 求满足$a^x $ ≡ $b (mod \\ p)$ 的最小非负整数 证明： 由欧拉定理的推论： $a^x ≡ a^{x\\ mod\\ \\varphi(p)} (mod\\ p)$ 所以可以得到最小循环节为$\\varphi(p)$ ，则缩小答案区间为$x \\in [0, \\varphi(p) - 1]$ 欧拉函数复杂度过大，则可以对欧拉函数进行放缩， 由 $\\varphi(p) &lt;= p$ 可以确定答案 $x$ 的取值为$[0, p].$ 通过公式对暴力枚举的算法进行优化： $令 x = kt - y, k = \\lfloor\\sqrt{q}\\rfloor + 1$ 则原式为 $a^{kt} ≡ ba^y ( mod p)$ $y$ 的范围是$[0, k - 1]$ 则可以枚举每个 y， 预处理同余符号右边的值，插入到hash表中，再枚举左边， $t\\in[1, k]$ 如果hash表中存在其值，则当前就是一个答案， 由于边界问题，需要特判 t = 0 的情况 $\\color{cyan}{板子如下}$ 12345678910111213141516171819202122232425262728293031int a, b, p;int bsgs(int a, int b, int p)&#123; if(1 % p == b % p) return 0; // 特判 t = 0, t = 0 则 b = 1; int k = sqrt(p) + 1; // sqrt(q) 下取整 + 1 unordered_map&lt;int, int&gt; mp; for(int i = 0, j = b % p; i &lt; k; i ++ )&#123; // hash存一下右值 mp[j] = i; // 小的 y 会被大的 y覆盖, 因为题目求的是最小的正整数解,故 y 越大越好 j = j * a % p; &#125; int ak = 1; for(int i = 0; i &lt; k; i ++ ) ak = ak * a % p; for(int i = 1, j = ak; i &lt;= k; i ++ )&#123; if(mp.count(j)) return i * k - mp[j]; // 如果存在与左值相同的右值 j = j * ak % p; &#125; return -1;&#125;signed main()&#123; while(cin &gt;&gt; a &gt;&gt; p &gt;&gt; b, a || b || p)&#123; int res = bsgs(a, b, p); if(res == -1)&#123; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; exBSGS: 问题: 区别是$a$ 和$q$ 不一定互质 首先 还是先特判 x = 0. 然后: 用$gcd(a, p)$ 来构建一个递归函数 当$gcd(a, p)$ == 1时进行普通的bsgs 当$gcd(a, p) != 1$ 时: $a^x + kp = b$ 设$gcd(a, p) == d$ 如果$d 不整除 p$ 则无解, 否则等式两边同除于 d 得到: $\\frac{a}{b}a^{x - 1} + k\\frac{p}{d} = \\frac{b}{d}$ 等价于同余方程 $\\frac{a}{b}a^{x - 1} ≡ \\frac{b}{d} ( mod\\ \\frac{p}{d})$ 由于$gcd(\\frac{a}{d} == 1)$ 所以把 $\\frac{a}{b}$ 移到右边,就是乘它的逆元 最后用新变量替换后: $(a^)^x ≡ b^ (mod \\ p^`)$ 替换后答案为$x + 1$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint a, b, p;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int bsgs(int a, int b, int p)&#123; if(1 % p == b % p) return 0; // 特判0 int k = sqrt(p) + 1; unordered_map&lt;int, int&gt; mp; for(int i = 0, j = b % p; i &lt; k; i ++ )&#123; mp[j] = i; j = j * a % p; &#125; int ak = 1; for(int i = 0; i &lt; k; i ++ ) ak = ak * a % p; for(int i = 1, j = ak; i &lt;= k; i ++ )&#123; if(mp.count(j)) return i * k - mp[j]; j = j * ak % p; &#125; return -2e9;&#125;int exbsgs(int a, int b,int p)&#123; b = (b % p + p) % p; // 防止b为负数 if(1 % p == b % p) return 0; int x, y; int d = exgcd(a, p, x, y); if(d &gt; 1)&#123; if(b % d) return -2e9; // 不能整除,无解 exgcd(a / d, p / d, x, y); return exbsgs(a, b / d * x % (p / d), p / d) + 1; // 注意 + 1 &#125; return bsgs(a, b, p);&#125;signed main()&#123; while(cin &gt;&gt; a &gt;&gt; p &gt;&gt; b, a || b || p)&#123; int res = exbsgs(a, b, p); if(res &lt; 0)&#123; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"杭电杯 1002 Dragon slayer","slug":"杭电杯-1002-Dragon-slayer","date":"2022-07-20T03:56:08.622Z","updated":"2022-07-20T03:56:11.776Z","comments":true,"path":"2022/07/20/杭电杯-1002-Dragon-slayer/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9D%AD%E7%94%B5%E6%9D%AF-1002-Dragon-slayer/","excerpt":"","text":"1002 Dragon slayer 题意 ： 给出 $n * m$ 的网格， 和起点，终点， 网格中有 k 面墙， 问至少破坏多少墙才能使起点终点连通。 思路： 由于 $n, k, m \\leq 15$ 则可以暴力枚举保留哪几面墙（二进制枚举， 然后对每一种方案求一下连通性。 小技巧： 由于网格数很少，则可以给每个点赋上编号，用 $st[i][j]$ 来表示能否从编号 i 的网格到达编号 j 的网格，或者说编号 i 与编号 j 之间是否有墙。 思路的思路： 数据一眼暴搜，对于每一面墙都有两个状态，选上或是不选，基于此，考虑到了二进制枚举，相较于普通爆更容易表示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define pii pair&lt;int, int&gt;const int N = 1010;int n, m, k;int vis[N]; // vis 表示该点是否走过int st[N][N], pos[N][N]; // st 表示 i 到 j 之间是否有墙 // pos 表示每个点的编号int dx[] = &#123;0, 1, 0, -1&#125;; // 方向int dy[] = &#123;1, 0, -1, 0&#125;;struct node&#123; int a, b, c, d;&#125;que[N]; // 表示墙int main()&#123; int t;cin &gt;&gt; t;while(t -- )&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int ans = k; for(int i = 0; i &lt;= 100; i ++ )&#123; for(int j = 0; j &lt;= 100; j ++ )&#123; pos[i][j] = 0; &#125; &#125; int cnt = 0; for(int i = 0; i &lt; n; i ++ )&#123; for(int j = 0; j &lt; m; j ++ )&#123; pos[i][j] = ++cnt; // 为每个点赋值一个编号 &#125; &#125; int u, v, s, t; cin &gt;&gt; u &gt;&gt; v &gt;&gt; s &gt;&gt; t; for(int j = 0; j &lt; k; j ++ )&#123; int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; que[j] = &#123;x1, y1, x2, y2&#125;; // 记录点 &#125; for(int ji = 0; ji &lt; (1 &lt;&lt; k); ji ++ )&#123; for(int i = 0; i &lt;= n * m + 5; i ++ ) vis[i] = 0; int res = k; for(int i = 0; i &lt; k; i ++ )&#123; if(ji &gt;&gt; i &amp; 1)&#123; // 因为 墙的数量只有 15，则可以二进制枚举 int x1 = que[i].a, y1 = que[i].b, x2 = que[i].c,y2 = que[i].d; if(x1 &gt; x2) swap(x1, x2); if(y1 &gt; y2) swap(y1, y2); if(x1 == x2)&#123; for(int j = y1; j &lt; y2; j ++ )&#123; st[pos[x1 - 1][j]][pos[x2][j]] = 1;// 表示两个点之间是否有墙。 st[pos[x2][j]][pos[x1 - 1][j]] = 1; &#125; &#125; else &#123; for(int j = x1; j &lt; x2; j ++ )&#123; st[pos[j][y1 - 1]][pos[j][y1]] = 1; st[pos[j][y1]][pos[j][y1 - 1]] = 1; &#125; &#125; res -- ; &#125; &#125; queue&lt;pii&gt; q; q.push(&#123;u, v&#125;); while(q.size())&#123; // bfs 求连通 pii top = q.front(); q.pop(); vis[pos[top.first][top.second]] = 1; for(int j = 0; j &lt; 4; j ++ )&#123; int x = top.first + dx[j], y = top.second + dy[j]; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue; if(vis[pos[x][y]]) continue; if(st[pos[top.first][top.second]][pos[x][y]]) continue; q.push(&#123;x, y&#125;); vis[pos[x][y]] = 1; &#125; &#125; for(int i = 0; i &lt; k; i ++ )&#123; if(ji &gt;&gt; i &amp; 1)&#123; int x1 = que[i].a, y1 = que[i].b, x2 = que[i].c,y2 = que[i].d; if(x1 &gt; x2) swap(x1, x2); if(y1 &gt; y2) swap(y1, y2); if(x1 == x2)&#123; for(int j = y1; j &lt; y2; j ++ )&#123; st[pos[x1 - 1][j]][pos[x2][j]] = 0;// 表示两个点之间是否有墙。 st[pos[x2][j]][pos[x1 - 1][j]] = 0; &#125; &#125; else &#123; for(int j = x1; j &lt; x2; j ++ )&#123; st[pos[j][y1 - 1]][pos[j][y1]] = 0; st[pos[j][y1]][pos[j][y1 - 1]] = 0; &#125; &#125; &#125; &#125; if(vis[pos[s][t]]) ans = min(res, ans); &#125; cout &lt;&lt; ans &lt;&lt; &#x27; &#x27;; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"二进制优化搜索","slug":"二进制优化搜索","permalink":"https://hanzug.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"杭电杯 1012.Alice and Bob","slug":"杭电杯-1012.Alice-and-Bob","date":"2022-07-20T02:37:38.973Z","updated":"2022-07-20T02:45:08.420Z","comments":true,"path":"2022/07/20/杭电杯-1012.Alice-and-Bob/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9D%AD%E7%94%B5%E6%9D%AF-1012.Alice-and-Bob/","excerpt":"","text":"题目 题意： alice和bob玩游戏，有 n个数在黑板上，当数中没有 0 的时候，alice可以选择把这些数分为两个集合，然后bob可以选择删掉其中一个集合的所有数，并且失衡下的另一个集合中的数全部减去 1，重复这个过程 结束条件： 黑板上有数减到 0 ，Alice win ​ 黑板上所有数都擦完了， bob win 思路： 考虑终止情况， 如果出现两个 1 ，则 Alice 可以将其分成两部分，则必有一个1减到了 0。 转换看法，题目可以看成，Alice每次可以把一对相同的数转化为一半数量的大小减一 的数。 我们只要从后往前遍历一遍看是否可以转换出 0. 1234567891011void solve()&#123; cin &gt;&gt; n; int f = 0; for(int i = 0; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for(int i = n; i &gt;= 1; i -- ) a[i - 1] += a[i] / 2; if(a[0]) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; &#x27;\\n&#x27;; else cout &lt;&lt; &quot;Bob&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"期望dp/概率dp","slug":"期望dp概率dp","date":"2022-07-19T16:32:36.313Z","updated":"2022-07-19T16:34:37.204Z","comments":true,"path":"2022/07/20/期望dp概率dp/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9C%9F%E6%9C%9Bdp%E6%A6%82%E7%8E%87dp/","excerpt":"","text":"定义 所求结果为某事件的期望的动态规划 在动态规划的基础上，将状态值改成了概率 和 期望 的相关值，本质依旧是动态规划 主要特点是，数学期望dp经常要先找到一个比较确定的起点 / 终点 来进行转移，故经常要逆推。 状态转移形如：$\\mathsf {F[ i ] = \\sum P[ i\\rightarrow j ] * f[ j ] + W[ i\\rightarrow j ]}$ 其中 p 为转移概率， w 为对答案的贡献 要点 注意终点或是起点的概率。一般很容易判断，进而进行状态转移。 注意初始化。 一个期望可以被分成多个子期望的加权和，即 $E(aA + bB + …) = aE(A) + bE(B)…$ 例题1 绿豆蛙的归宿 题目描述： 给出张 n 个点 m 条边的有向无环图，起点为 1，终点为 n，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 k 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\\frac 1k$ 现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？ 思路： $f[i] 为从 i 跳到 n 的期望长度$ 状态转移起点: $f[n]$ 答案：$f[1]$ 因为是有向无环图，直接由拓扑序从后往前推一遍 1234567891011121314int n, m;int h[N], e[M], w[M], ne[M], idx;int dout[N];double f[N];double dp(int u)&#123; if(f[u] &gt;= 0) return f[u]; //记忆化搜索 f[u] = 0;// 没搜到过，是终点， 初始化 n 到 n 的距离期望为 0。 （确实好判断 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; f[u] += (w[i] + dp(j)) / dout[u]; // 1 / dout[u] 为概率 p, w[i] + dp(j) 为权值 &#125; return f[u];&#125; 例题2： 麻将模拟 题意： 开局13个麻将，求摸多少局能凑够7个对子的期望。 思路： 先确定终止状态，即手中有了7个对子，没有单牌。回合数为 0。 12345678910111213141516171819202122232425262728void init()&#123; // 初始化的终点为 0, 凑成七个对子需要 0 局，即i == 0的情况 // 0 不需要初始化了。 for(int i = 1; i &lt;= 13; i += 2)&#123; for(int j = 1; j &lt;= 123; j ++ )&#123; if(i == 1) f[i][j] = (1 + ((j - 3) * qmi(j, mod - 2) % mod) * f[i][j - 1]) % mod; else f[i][j] = (1 + (3 * i * qmi(j, mod - 2) % mod) * f[i - 2][j - 1] % mod + ((j - 3 * i) * qmi(j, mod - 2) % mod) * f[i][j - 1] % mod) % mod; &#125; &#125;&#125;void solve()&#123; cin &gt;&gt; (s + 1); mp.clear(); for(int i = 2; i &lt;= 26; i += 2)&#123; string s1 = &quot;&quot;; s1 += s[i - 1]; s1 += s[i]; mp[s1] ++ ; &#125; int cnt = 0; for(auto u : mp)&#123; if(u.second == 1) cnt ++ ; &#125; cout &lt;&lt; f[cnt][123];&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"期望dp/概率dp","slug":"期望dp-概率dp","permalink":"https://hanzug.github.io/tags/%E6%9C%9F%E6%9C%9Bdp-%E6%A6%82%E7%8E%87dp/"}]},{"title":"Changign Jewels","slug":"Changign-Jewels","date":"2022-07-19T11:59:54.187Z","updated":"2022-07-19T13:59:16.802Z","comments":true,"path":"2022/07/19/Changign-Jewels/","link":"","permalink":"https://hanzug.github.io/2022/07/19/Changign-Jewels/","excerpt":"","text":"题目 大意: 开局一颗宝石，有两种操作 1.把一颗 N 级的红宝石变成一个 N - 1 级的红宝石和 X 个 N 级的蓝宝石 2.把一颗 N 级的蓝宝石变成一个 N - 1 级的蓝宝石和 Y 个 N - 1 级的红宝石 问：怎么操作使得最后得到的一级的蓝宝石最多 心情：😢 函数写法 ： 由于宝石数量开局时是唯一的， 故可以以第一个宝石为源头，每一个宝石都是一个分支，直到分成等级为1，最后判断这个一级的宝石是否为蓝色。 123456789101112131415161718int N, X, Y;#define int long longint calc(int level, bool is_red)&#123; if(level == 1) return is_red ? 0 : 1; if(is_red)&#123; return calc(level - 1, 1) + calc(level, 0) * X; &#125; else &#123; return calc(level - 1, 1) + calc(level - 1, 0) * Y; &#125;&#125;signed main()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y; cout &lt;&lt; calc(N, true) &lt;&lt; &#x27;\\n&#x27;;&#125; dp实现 ： 1234567891011int N, X, Y, r[12], b[12];void solve()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y; r[1] = 0, b[1] = 1; for(int n = 2; n &lt;= N; n ++ )&#123; b[n] = r[n - 1] + b[n - 1] * Y; r[n] = r[n - 1] + b[n] * X; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Qpwoeirut And The City","slug":"Qpwoeirut-And-The-City","date":"2022-07-19T09:48:24.715Z","updated":"2022-07-19T09:48:33.988Z","comments":true,"path":"2022/07/19/Qpwoeirut-And-The-City/","link":"","permalink":"https://hanzug.github.io/2022/07/19/Qpwoeirut-And-The-City/","excerpt":"","text":"题目 大意： 给你n栋楼，cool楼的定义为比它左右两栋的楼层都高，只可以添加楼层，不可以删减，求在建造尽可能多的cool楼的情况下添加的最少楼层。 1）如果 n 是奇数的话， 那 2 ~ n - 1 的 cool楼 一定是 高低高低…..高（1010…. 1）这样来分配才是最多的 2）如果 n 为偶数， 则又可以分情况 ​ 1.第2个建筑为高，第 n - 1 个建筑为低， 即 01010100 ​ 2.第2个建筑为低，第 n - 1 个建筑为高，即 00101010 ​ 3.基于前两种情况，我们可以在数组的中间找到一个连续两个低的位置为分界点。 ​ 即0101 00 1010 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int n;int a[N];int ans1[N], ans2[N];void solve()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++ )&#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n + 2; i ++ )&#123; ans1[i] = 0; ans2[i] = 0; &#125; int ans = 0; if(n &amp; 1)&#123; // n 为奇数 for(int i = 2; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1]) ans += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; ans = 2e14; for(int i = 2; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1])&#123; ans1[i] += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; if(i &gt;= 4) ans1[i] += ans1[i - 2]; &#125; for(int i = 3; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1])&#123; ans2[i] += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; if(i &gt;= 3) ans2[i] += ans2[i - 2]; &#125; for(int i = 2; i &lt;= n - 4; i += 2)&#123; ans = min(ans, ans1[i] + ans2[n - 1] - ans2[i + 2]); //注意细节，因为ans1和ans2的高分别相邻，故加和的时候只需中间差一个就凑够了两个低 &#125; ans = min(ans, min(ans1[n - 2], ans2[n - 1])); cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Mocha and Railgun","slug":"Mocha and Railgun","date":"2022-07-18T14:16:06.690Z","updated":"2022-07-18T14:16:06.690Z","comments":true,"path":"2022/07/18/Mocha and Railgun/","link":"","permalink":"https://hanzug.github.io/2022/07/18/Mocha%20and%20Railgun/","excerpt":"","text":"题目 题目大意： 给定一个圆和严格位于圆内的一点 P Mocha 会从点 P 向任意角度发射一个长度为 2d 的电磁炮 电磁炮底边的中点为点 P 且两端位于圆内 询问单次发射能摧毁的最大圆弧长 1 ≤ T ≤ 1000*,* −109 ≤ x, y ≤ 109*,* 1 ≤ r,d ≤ 109 复习了初中知识（😀 ———————————— 知道了居然还有acos函数 12345678910double r, x, y, d;void solve()&#123; cin &gt;&gt; r; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; double res = sqrt(x * x + y * y); double t = acos(-1) - acos((d - res) / r) - acos((d + res) / r); printf(&quot;%10f\\n&quot;, t * r);&#125;","categories":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"anti-nim","slug":"未命名","date":"2022-07-18T02:16:56.753Z","updated":"2022-07-18T10:43:18.041Z","comments":true,"path":"2022/07/18/未命名/","link":"","permalink":"https://hanzug.github.io/2022/07/18/%E6%9C%AA%E5%91%BD%E5%90%8D/","excerpt":"","text":"题目 Alice 和 Bob 正在玩一个游戏，双方都很聪明。游戏是这样的，给出一个正整数 n，然后每次轮流操作，每次操作需要将数 n 除以 $2^k $。Alice 先手，谁先将数 n 变为 1 则谁输 nim游戏变形。 对 n 进行质因数分解， 每个质因子及其指数又化为取石子游戏。 auti-nim: 终止状态：最后一个取石头的人输。 . 先手必胜条件： 1.所有石子的个数为1， 且 all_xor 为0. 2.至少有一堆石子的个数大于1， 且all_xor $\\neq$ 0. $$\\Updownarrow$$ 123456789101112131415161718192021222324using ll = long long; ll n, ans; int main()&#123; cin &gt;&gt; n; bool flag = 0; for(ll i = 2; i * i &lt;= n; i ++ )&#123; if(n % i == 0)&#123; int cnt = 0; while(n % i == 0) n /= i, cnt ++ ; ans ^= cnt; if(cnt != 1) flag = 1; &#125; &#125; if(n &gt; 1) ans ^= 1; if((!flag &amp;&amp; !ans) || (flag &amp;&amp; ans)) puts(&quot;Alice win&quot;); else puts(&quot;Bob win&quot;); return 0;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]}],"categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"},{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"bitset","slug":"bitset","permalink":"https://hanzug.github.io/tags/bitset/"},{"name":"位运算","slug":"位运算","permalink":"https://hanzug.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"二进制优化搜索","slug":"二进制优化搜索","permalink":"https://hanzug.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"期望dp/概率dp","slug":"期望dp-概率dp","permalink":"https://hanzug.github.io/tags/%E6%9C%9F%E6%9C%9Bdp-%E6%A6%82%E7%8E%87dp/"}]}