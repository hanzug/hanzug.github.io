{"meta":{"title":null,"subtitle":"","description":"","author":"hanzug","url":"https://hanzug.github.io","root":"/"},"pages":[{"title":"notes","date":"2022-07-18T01:02:32.000Z","updated":"2022-07-18T01:37:38.050Z","comments":true,"path":"categories/index.html","permalink":"https://hanzug.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-18T02:13:49.000Z","updated":"2022-07-18T02:23:11.950Z","comments":true,"path":"tags/index.html","permalink":"https://hanzug.github.io/tags/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-07-18T01:09:01.000Z","updated":"2022-07-18T01:09:01.228Z","comments":true,"path":"notes/index.html","permalink":"https://hanzug.github.io/notes/index.html","excerpt":"","text":""}],"posts":[{"title":"BSGS","slug":"BSGS","date":"2022-07-20T10:12:35.117Z","updated":"2022-07-20T10:15:40.932Z","comments":true,"path":"2022/07/20/BSGS/","link":"","permalink":"https://hanzug.github.io/2022/07/20/BSGS/","excerpt":"","text":"普通BSGS 适用问题： 给定正整数，$a, b, p, 且a与p互质$ 求满足$a^x $ ≡ $b (mod \\ p)$ 的最小非负整数 证明： 由欧拉定理的推论： $a^x ≡ a^{x\\ mod\\ \\varphi(p)} (mod\\ p)$ 所以可以得到最小循环节为$\\varphi(p)$ ，则缩小答案区间为$x \\in [0, \\varphi(p) - 1]$ 欧拉函数复杂度过大，则可以对欧拉函数进行放缩， 由 $\\varphi(p) &lt;= p$ 可以确定答案 $x$ 的取值为$[0, p].$ 通过公式对暴力枚举的算法进行优化： $令 x = kt - y, k = \\lfloor\\sqrt{q}\\rfloor + 1$ 则原式为 $a^{kt} ≡ ba^y ( mod p)$ $y$ 的范围是$[0, k - 1]$ 则可以枚举每个 y， 预处理同余符号右边的值，插入到hash表中，再枚举左边， $t\\in[1, k]$ 如果hash表中存在其值，则当前就是一个答案， 由于边界问题，需要特判 t = 0 的情况 $\\color{cyan}{板子如下}$ 12345678910111213141516171819202122232425262728293031int a, b, p;int bsgs(int a, int b, int p)&#123; if(1 % p == b % p) return 0; // 特判 t = 0, t = 0 则 b = 1; int k = sqrt(p) + 1; // sqrt(q) 下取整 + 1 unordered_map&lt;int, int&gt; mp; for(int i = 0, j = b % p; i &lt; k; i ++ )&#123; // hash存一下右值 mp[j] = i; // 小的 y 会被大的 y覆盖, 因为题目求的是最小的正整数解,故 y 越大越好 j = j * a % p; &#125; int ak = 1; for(int i = 0; i &lt; k; i ++ ) ak = ak * a % p; for(int i = 1, j = ak; i &lt;= k; i ++ )&#123; if(mp.count(j)) return i * k - mp[j]; // 如果存在与左值相同的右值 j = j * ak % p; &#125; return -1;&#125;signed main()&#123; while(cin &gt;&gt; a &gt;&gt; p &gt;&gt; b, a || b || p)&#123; int res = bsgs(a, b, p); if(res == -1)&#123; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;; &#125;&#125; exBSGS: 问题: 区别是$a$ 和$q$ 不一定互质 首先 还是先特判 x = 0. 然后: 用$gcd(a, p)$ 来构建一个递归函数 当$gcd(a, p)$ == 1时进行普通的bsgs 当$gcd(a, p) != 1$ 时: $a^x + kp = b$ 设$gcd(a, p) == d$ 如果$d 不整除 p$ 则无解, 否则等式两边同除于 d 得到: $\\frac{a}{b}a^{x - 1} + k\\frac{p}{d} = \\frac{b}{d}$ 等价于同余方程 $\\frac{a}{b}a^{x - 1} ≡ \\frac{b}{d} ( mod\\ \\frac{p}{d})$ 由于$gcd(\\frac{a}{d} == 1)$ 所以把 $\\frac{a}{b}$ 移到右边,就是乘它的逆元 最后用新变量替换后: $(a^)^x ≡ b^ (mod \\ p^`)$ 替换后答案为$x + 1$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;bits/stdc++.h&gt;using namespace std;#define int long longint a, b, p;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123; if(!b)&#123; x = 1, y = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y -= a / b * x; return d;&#125;int bsgs(int a, int b, int p)&#123; if(1 % p == b % p) return 0; // 特判0 int k = sqrt(p) + 1; unordered_map&lt;int, int&gt; mp; for(int i = 0, j = b % p; i &lt; k; i ++ )&#123; mp[j] = i; j = j * a % p; &#125; int ak = 1; for(int i = 0; i &lt; k; i ++ ) ak = ak * a % p; for(int i = 1, j = ak; i &lt;= k; i ++ )&#123; if(mp.count(j)) return i * k - mp[j]; j = j * ak % p; &#125; return -2e9;&#125;int exbsgs(int a, int b,int p)&#123; b = (b % p + p) % p; // 防止b为负数 if(1 % p == b % p) return 0; int x, y; int d = exgcd(a, p, x, y); if(d &gt; 1)&#123; if(b % d) return -2e9; // 不能整除,无解 exgcd(a / d, p / d, x, y); return exbsgs(a, b / d * x % (p / d), p / d) + 1; // 注意 + 1 &#125; return bsgs(a, b, p);&#125;signed main()&#123; while(cin &gt;&gt; a &gt;&gt; p &gt;&gt; b, a || b || p)&#123; int res = exbsgs(a, b, p); if(res &lt; 0)&#123; cout &lt;&lt; &quot;No Solution&quot; &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"杭电杯 1002 Dragon slayer","slug":"杭电杯-1002-Dragon-slayer","date":"2022-07-20T03:56:08.622Z","updated":"2022-07-20T03:56:11.776Z","comments":true,"path":"2022/07/20/杭电杯-1002-Dragon-slayer/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9D%AD%E7%94%B5%E6%9D%AF-1002-Dragon-slayer/","excerpt":"","text":"1002 Dragon slayer 题意 ： 给出 $n * m$ 的网格， 和起点，终点， 网格中有 k 面墙， 问至少破坏多少墙才能使起点终点连通。 思路： 由于 $n, k, m \\leq 15$ 则可以暴力枚举保留哪几面墙（二进制枚举， 然后对每一种方案求一下连通性。 小技巧： 由于网格数很少，则可以给每个点赋上编号，用 $st[i][j]$ 来表示能否从编号 i 的网格到达编号 j 的网格，或者说编号 i 与编号 j 之间是否有墙。 思路的思路： 数据一眼暴搜，对于每一面墙都有两个状态，选上或是不选，基于此，考虑到了二进制枚举，相较于普通爆更容易表示。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;#define pii pair&lt;int, int&gt;const int N = 1010;int n, m, k;int vis[N]; // vis 表示该点是否走过int st[N][N], pos[N][N]; // st 表示 i 到 j 之间是否有墙 // pos 表示每个点的编号int dx[] = &#123;0, 1, 0, -1&#125;; // 方向int dy[] = &#123;1, 0, -1, 0&#125;;struct node&#123; int a, b, c, d;&#125;que[N]; // 表示墙int main()&#123; int t;cin &gt;&gt; t;while(t -- )&#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; int ans = k; for(int i = 0; i &lt;= 100; i ++ )&#123; for(int j = 0; j &lt;= 100; j ++ )&#123; pos[i][j] = 0; &#125; &#125; int cnt = 0; for(int i = 0; i &lt; n; i ++ )&#123; for(int j = 0; j &lt; m; j ++ )&#123; pos[i][j] = ++cnt; // 为每个点赋值一个编号 &#125; &#125; int u, v, s, t; cin &gt;&gt; u &gt;&gt; v &gt;&gt; s &gt;&gt; t; for(int j = 0; j &lt; k; j ++ )&#123; int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; que[j] = &#123;x1, y1, x2, y2&#125;; // 记录点 &#125; for(int ji = 0; ji &lt; (1 &lt;&lt; k); ji ++ )&#123; for(int i = 0; i &lt;= n * m + 5; i ++ ) vis[i] = 0; int res = k; for(int i = 0; i &lt; k; i ++ )&#123; if(ji &gt;&gt; i &amp; 1)&#123; // 因为 墙的数量只有 15，则可以二进制枚举 int x1 = que[i].a, y1 = que[i].b, x2 = que[i].c,y2 = que[i].d; if(x1 &gt; x2) swap(x1, x2); if(y1 &gt; y2) swap(y1, y2); if(x1 == x2)&#123; for(int j = y1; j &lt; y2; j ++ )&#123; st[pos[x1 - 1][j]][pos[x2][j]] = 1;// 表示两个点之间是否有墙。 st[pos[x2][j]][pos[x1 - 1][j]] = 1; &#125; &#125; else &#123; for(int j = x1; j &lt; x2; j ++ )&#123; st[pos[j][y1 - 1]][pos[j][y1]] = 1; st[pos[j][y1]][pos[j][y1 - 1]] = 1; &#125; &#125; res -- ; &#125; &#125; queue&lt;pii&gt; q; q.push(&#123;u, v&#125;); while(q.size())&#123; // bfs 求连通 pii top = q.front(); q.pop(); vis[pos[top.first][top.second]] = 1; for(int j = 0; j &lt; 4; j ++ )&#123; int x = top.first + dx[j], y = top.second + dy[j]; if(x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) continue; if(vis[pos[x][y]]) continue; if(st[pos[top.first][top.second]][pos[x][y]]) continue; q.push(&#123;x, y&#125;); vis[pos[x][y]] = 1; &#125; &#125; for(int i = 0; i &lt; k; i ++ )&#123; if(ji &gt;&gt; i &amp; 1)&#123; int x1 = que[i].a, y1 = que[i].b, x2 = que[i].c,y2 = que[i].d; if(x1 &gt; x2) swap(x1, x2); if(y1 &gt; y2) swap(y1, y2); if(x1 == x2)&#123; for(int j = y1; j &lt; y2; j ++ )&#123; st[pos[x1 - 1][j]][pos[x2][j]] = 0;// 表示两个点之间是否有墙。 st[pos[x2][j]][pos[x1 - 1][j]] = 0; &#125; &#125; else &#123; for(int j = x1; j &lt; x2; j ++ )&#123; st[pos[j][y1 - 1]][pos[j][y1]] = 0; st[pos[j][y1]][pos[j][y1 - 1]] = 0; &#125; &#125; &#125; &#125; if(vis[pos[s][t]]) ans = min(res, ans); &#125; cout &lt;&lt; ans &lt;&lt; &#x27; &#x27;; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"二进制优化搜索","slug":"二进制优化搜索","permalink":"https://hanzug.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/"}]},{"title":"杭电杯 1012.Alice and Bob","slug":"杭电杯-1012.Alice-and-Bob","date":"2022-07-20T02:37:38.973Z","updated":"2022-07-20T02:45:08.420Z","comments":true,"path":"2022/07/20/杭电杯-1012.Alice-and-Bob/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9D%AD%E7%94%B5%E6%9D%AF-1012.Alice-and-Bob/","excerpt":"","text":"题目 题意： alice和bob玩游戏，有 n个数在黑板上，当数中没有 0 的时候，alice可以选择把这些数分为两个集合，然后bob可以选择删掉其中一个集合的所有数，并且失衡下的另一个集合中的数全部减去 1，重复这个过程 结束条件： 黑板上有数减到 0 ，Alice win ​ 黑板上所有数都擦完了， bob win 思路： 考虑终止情况， 如果出现两个 1 ，则 Alice 可以将其分成两部分，则必有一个1减到了 0。 转换看法，题目可以看成，Alice每次可以把一对相同的数转化为一半数量的大小减一 的数。 我们只要从后往前遍历一遍看是否可以转换出 0. 1234567891011void solve()&#123; cin &gt;&gt; n; int f = 0; for(int i = 0; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for(int i = n; i &gt;= 1; i -- ) a[i - 1] += a[i] / 2; if(a[0]) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; &#x27;\\n&#x27;; else cout &lt;&lt; &quot;Bob&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"期望dp/概率dp","slug":"期望dp概率dp","date":"2022-07-19T16:32:36.313Z","updated":"2022-07-19T16:34:37.204Z","comments":true,"path":"2022/07/20/期望dp概率dp/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9C%9F%E6%9C%9Bdp%E6%A6%82%E7%8E%87dp/","excerpt":"","text":"定义 所求结果为某事件的期望的动态规划 在动态规划的基础上，将状态值改成了概率 和 期望 的相关值，本质依旧是动态规划 主要特点是，数学期望dp经常要先找到一个比较确定的起点 / 终点 来进行转移，故经常要逆推。 状态转移形如：$\\mathsf {F[ i ] = \\sum P[ i\\rightarrow j ] * f[ j ] + W[ i\\rightarrow j ]}$ 其中 p 为转移概率， w 为对答案的贡献 要点 注意终点或是起点的概率。一般很容易判断，进而进行状态转移。 注意初始化。 一个期望可以被分成多个子期望的加权和，即 $E(aA + bB + …) = aE(A) + bE(B)…$ 例题1 绿豆蛙的归宿 题目描述： 给出张 n 个点 m 条边的有向无环图，起点为 1，终点为 n，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 k 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\\frac 1k$ 现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？ 思路： $f[i] 为从 i 跳到 n 的期望长度$ 状态转移起点: $f[n]$ 答案：$f[1]$ 因为是有向无环图，直接由拓扑序从后往前推一遍 1234567891011121314int n, m;int h[N], e[M], w[M], ne[M], idx;int dout[N];double f[N];double dp(int u)&#123; if(f[u] &gt;= 0) return f[u]; //记忆化搜索 f[u] = 0;// 没搜到过，是终点， 初始化 n 到 n 的距离期望为 0。 （确实好判断 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; f[u] += (w[i] + dp(j)) / dout[u]; // 1 / dout[u] 为概率 p, w[i] + dp(j) 为权值 &#125; return f[u];&#125; 例题2： 麻将模拟 题意： 开局13个麻将，求摸多少局能凑够7个对子的期望。 思路： 先确定终止状态，即手中有了7个对子，没有单牌。回合数为 0。 12345678910111213141516171819202122232425262728void init()&#123; // 初始化的终点为 0, 凑成七个对子需要 0 局，即i == 0的情况 // 0 不需要初始化了。 for(int i = 1; i &lt;= 13; i += 2)&#123; for(int j = 1; j &lt;= 123; j ++ )&#123; if(i == 1) f[i][j] = (1 + ((j - 3) * qmi(j, mod - 2) % mod) * f[i][j - 1]) % mod; else f[i][j] = (1 + (3 * i * qmi(j, mod - 2) % mod) * f[i - 2][j - 1] % mod + ((j - 3 * i) * qmi(j, mod - 2) % mod) * f[i][j - 1] % mod) % mod; &#125; &#125;&#125;void solve()&#123; cin &gt;&gt; (s + 1); mp.clear(); for(int i = 2; i &lt;= 26; i += 2)&#123; string s1 = &quot;&quot;; s1 += s[i - 1]; s1 += s[i]; mp[s1] ++ ; &#125; int cnt = 0; for(auto u : mp)&#123; if(u.second == 1) cnt ++ ; &#125; cout &lt;&lt; f[cnt][123];&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"期望dp/概率dp","slug":"期望dp-概率dp","permalink":"https://hanzug.github.io/tags/%E6%9C%9F%E6%9C%9Bdp-%E6%A6%82%E7%8E%87dp/"}]},{"title":"Changign Jewels","slug":"Changign-Jewels","date":"2022-07-19T11:59:54.187Z","updated":"2022-07-19T13:59:16.802Z","comments":true,"path":"2022/07/19/Changign-Jewels/","link":"","permalink":"https://hanzug.github.io/2022/07/19/Changign-Jewels/","excerpt":"","text":"题目 大意: 开局一颗宝石，有两种操作 1.把一颗 N 级的红宝石变成一个 N - 1 级的红宝石和 X 个 N 级的蓝宝石 2.把一颗 N 级的蓝宝石变成一个 N - 1 级的蓝宝石和 Y 个 N - 1 级的红宝石 问：怎么操作使得最后得到的一级的蓝宝石最多 心情：😢 函数写法 ： 由于宝石数量开局时是唯一的， 故可以以第一个宝石为源头，每一个宝石都是一个分支，直到分成等级为1，最后判断这个一级的宝石是否为蓝色。 123456789101112131415161718int N, X, Y;#define int long longint calc(int level, bool is_red)&#123; if(level == 1) return is_red ? 0 : 1; if(is_red)&#123; return calc(level - 1, 1) + calc(level, 0) * X; &#125; else &#123; return calc(level - 1, 1) + calc(level - 1, 0) * Y; &#125;&#125;signed main()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y; cout &lt;&lt; calc(N, true) &lt;&lt; &#x27;\\n&#x27;;&#125; dp实现 ： 1234567891011int N, X, Y, r[12], b[12];void solve()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y; r[1] = 0, b[1] = 1; for(int n = 2; n &lt;= N; n ++ )&#123; b[n] = r[n - 1] + b[n - 1] * Y; r[n] = r[n - 1] + b[n] * X; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Qpwoeirut And The City","slug":"Qpwoeirut-And-The-City","date":"2022-07-19T09:48:24.715Z","updated":"2022-07-19T09:48:33.988Z","comments":true,"path":"2022/07/19/Qpwoeirut-And-The-City/","link":"","permalink":"https://hanzug.github.io/2022/07/19/Qpwoeirut-And-The-City/","excerpt":"","text":"题目 大意： 给你n栋楼，cool楼的定义为比它左右两栋的楼层都高，只可以添加楼层，不可以删减，求在建造尽可能多的cool楼的情况下添加的最少楼层。 1）如果 n 是奇数的话， 那 2 ~ n - 1 的 cool楼 一定是 高低高低…..高（1010…. 1）这样来分配才是最多的 2）如果 n 为偶数， 则又可以分情况 ​ 1.第2个建筑为高，第 n - 1 个建筑为低， 即 01010100 ​ 2.第2个建筑为低，第 n - 1 个建筑为高，即 00101010 ​ 3.基于前两种情况，我们可以在数组的中间找到一个连续两个低的位置为分界点。 ​ 即0101 00 1010 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int n;int a[N];int ans1[N], ans2[N];void solve()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++ )&#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n + 2; i ++ )&#123; ans1[i] = 0; ans2[i] = 0; &#125; int ans = 0; if(n &amp; 1)&#123; // n 为奇数 for(int i = 2; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1]) ans += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; ans = 2e14; for(int i = 2; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1])&#123; ans1[i] += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; if(i &gt;= 4) ans1[i] += ans1[i - 2]; &#125; for(int i = 3; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1])&#123; ans2[i] += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; if(i &gt;= 3) ans2[i] += ans2[i - 2]; &#125; for(int i = 2; i &lt;= n - 4; i += 2)&#123; ans = min(ans, ans1[i] + ans2[n - 1] - ans2[i + 2]); //注意细节，因为ans1和ans2的高分别相邻，故加和的时候只需中间差一个就凑够了两个低 &#125; ans = min(ans, min(ans1[n - 2], ans2[n - 1])); cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Mocha and Railgun","slug":"Mocha and Railgun","date":"2022-07-18T14:16:06.690Z","updated":"2022-07-18T14:16:06.690Z","comments":true,"path":"2022/07/18/Mocha and Railgun/","link":"","permalink":"https://hanzug.github.io/2022/07/18/Mocha%20and%20Railgun/","excerpt":"","text":"题目 题目大意： 给定一个圆和严格位于圆内的一点 P Mocha 会从点 P 向任意角度发射一个长度为 2d 的电磁炮 电磁炮底边的中点为点 P 且两端位于圆内 询问单次发射能摧毁的最大圆弧长 1 ≤ T ≤ 1000*,* −109 ≤ x, y ≤ 109*,* 1 ≤ r,d ≤ 109 复习了初中知识（😀 ———————————— 知道了居然还有acos函数 12345678910double r, x, y, d;void solve()&#123; cin &gt;&gt; r; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; double res = sqrt(x * x + y * y); double t = acos(-1) - acos((d - res) / r) - acos((d + res) / r); printf(&quot;%10f\\n&quot;, t * r);&#125;","categories":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"anti-nim","slug":"未命名","date":"2022-07-18T02:16:56.753Z","updated":"2022-07-18T10:43:18.041Z","comments":true,"path":"2022/07/18/未命名/","link":"","permalink":"https://hanzug.github.io/2022/07/18/%E6%9C%AA%E5%91%BD%E5%90%8D/","excerpt":"","text":"题目 Alice 和 Bob 正在玩一个游戏，双方都很聪明。游戏是这样的，给出一个正整数 n，然后每次轮流操作，每次操作需要将数 n 除以 $2^k $。Alice 先手，谁先将数 n 变为 1 则谁输 nim游戏变形。 对 n 进行质因数分解， 每个质因子及其指数又化为取石子游戏。 auti-nim: 终止状态：最后一个取石头的人输。 . 先手必胜条件： 1.所有石子的个数为1， 且 all_xor 为0. 2.至少有一堆石子的个数大于1， 且all_xor $\\neq$ 0. $$\\Updownarrow$$ 123456789101112131415161718192021222324using ll = long long; ll n, ans; int main()&#123; cin &gt;&gt; n; bool flag = 0; for(ll i = 2; i * i &lt;= n; i ++ )&#123; if(n % i == 0)&#123; int cnt = 0; while(n % i == 0) n /= i, cnt ++ ; ans ^= cnt; if(cnt != 1) flag = 1; &#125; &#125; if(n &gt; 1) ans ^= 1; if((!flag &amp;&amp; !ans) || (flag &amp;&amp; ans)) puts(&quot;Alice win&quot;); else puts(&quot;Bob win&quot;); return 0;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]}],"categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"},{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"二进制优化搜索","slug":"二进制优化搜索","permalink":"https://hanzug.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BC%98%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"期望dp/概率dp","slug":"期望dp-概率dp","permalink":"https://hanzug.github.io/tags/%E6%9C%9F%E6%9C%9Bdp-%E6%A6%82%E7%8E%87dp/"}]}