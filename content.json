{"meta":{"title":null,"subtitle":"","description":"","author":"hanzug","url":"https://hanzug.github.io","root":"/"},"pages":[{"title":"notes","date":"2022-07-18T01:02:32.000Z","updated":"2022-07-18T01:37:38.050Z","comments":true,"path":"categories/index.html","permalink":"https://hanzug.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-07-18T02:13:49.000Z","updated":"2022-07-18T02:23:11.950Z","comments":true,"path":"tags/index.html","permalink":"https://hanzug.github.io/tags/index.html","excerpt":"","text":""},{"title":"notes","date":"2022-07-18T01:09:01.000Z","updated":"2022-07-18T01:09:01.228Z","comments":true,"path":"notes/index.html","permalink":"https://hanzug.github.io/notes/index.html","excerpt":"","text":""}],"posts":[{"title":"杭电杯 1012.Alice and Bob","slug":"杭电杯-1012.Alice-and-Bob","date":"2022-07-20T02:37:38.973Z","updated":"2022-07-20T02:42:32.551Z","comments":true,"path":"2022/07/20/杭电杯-1012.Alice-and-Bob/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9D%AD%E7%94%B5%E6%9D%AF-1012.Alice-and-Bob/","excerpt":"","text":"题意： alice和bob玩游戏，有 n个数在黑板上，当数中没有 0 的时候，alice可以选择把这些数分为两个集合，然后bob可以选择删掉其中一个集合的所有数，并且失衡下的另一个集合中的数全部减去 1，重复这个过程 结束条件： 黑板上有数减到 0 ，Alice win ​ 黑板上所有数都擦完了， bob win 思路： 考虑终止情况， 如果出现两个 1 ，则 Alice 可以将其分成两部分，则必有一个1减到了 0。 转换看法，题目可以看成，Alice每次可以把一对相同的数转化为一半数量的大小减一 的数。 我们只要从后往前遍历一遍看是否可以转换出 0. 1234567891011void solve()&#123; cin &gt;&gt; n; int f = 0; for(int i = 0; i &lt;= n; i ++ ) cin &gt;&gt; a[i]; for(int i = n; i &gt;= 1; i -- ) a[i - 1] += a[i] / 2; if(a[0]) cout &lt;&lt; &quot;Alice&quot; &lt;&lt; &#x27;\\n&#x27;; else cout &lt;&lt; &quot;Bob&quot; &lt;&lt; &#x27;\\n&#x27;;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]},{"title":"期望dp/概率dp","slug":"期望dp概率dp","date":"2022-07-19T16:32:36.313Z","updated":"2022-07-19T16:34:37.204Z","comments":true,"path":"2022/07/20/期望dp概率dp/","link":"","permalink":"https://hanzug.github.io/2022/07/20/%E6%9C%9F%E6%9C%9Bdp%E6%A6%82%E7%8E%87dp/","excerpt":"","text":"定义 所求结果为某事件的期望的动态规划 在动态规划的基础上，将状态值改成了概率 和 期望 的相关值，本质依旧是动态规划 主要特点是，数学期望dp经常要先找到一个比较确定的起点 / 终点 来进行转移，故经常要逆推。 状态转移形如：$\\mathsf {F[ i ] = \\sum P[ i\\rightarrow j ] * f[ j ] + W[ i\\rightarrow j ]}$ 其中 p 为转移概率， w 为对答案的贡献 要点 注意终点或是起点的概率。一般很容易判断，进而进行状态转移。 注意初始化。 一个期望可以被分成多个子期望的加权和，即 $E(aA + bB + …) = aE(A) + bE(B)…$ 例题1 绿豆蛙的归宿 题目描述： 给出张 n 个点 m 条边的有向无环图，起点为 1，终点为 n，每条边都有一个长度，并且从起点出发能够到达所有的点，所有的点也都能够到达终点。绿豆蛙从起点出发，走向终点。 到达每一个顶点时，如果该节点有 k 条出边，绿豆蛙可以选择任意一条边离开该点，并且走向每条边的概率为 $\\frac 1k$ 现在绿豆蛙想知道，从起点走到终点的所经过的路径总长度期望是多少？ 思路： $f[i] 为从 i 跳到 n 的期望长度$ 状态转移起点: $f[n]$ 答案：$f[1]$ 因为是有向无环图，直接由拓扑序从后往前推一遍 1234567891011121314int n, m;int h[N], e[M], w[M], ne[M], idx;int dout[N];double f[N];double dp(int u)&#123; if(f[u] &gt;= 0) return f[u]; //记忆化搜索 f[u] = 0;// 没搜到过，是终点， 初始化 n 到 n 的距离期望为 0。 （确实好判断 for(int i = h[u]; i != -1; i = ne[i])&#123; int j = e[i]; f[u] += (w[i] + dp(j)) / dout[u]; // 1 / dout[u] 为概率 p, w[i] + dp(j) 为权值 &#125; return f[u];&#125; 例题2： 麻将模拟 题意： 开局13个麻将，求摸多少局能凑够7个对子的期望。 思路： 先确定终止状态，即手中有了7个对子，没有单牌。回合数为 0。 12345678910111213141516171819202122232425262728void init()&#123; // 初始化的终点为 0, 凑成七个对子需要 0 局，即i == 0的情况 // 0 不需要初始化了。 for(int i = 1; i &lt;= 13; i += 2)&#123; for(int j = 1; j &lt;= 123; j ++ )&#123; if(i == 1) f[i][j] = (1 + ((j - 3) * qmi(j, mod - 2) % mod) * f[i][j - 1]) % mod; else f[i][j] = (1 + (3 * i * qmi(j, mod - 2) % mod) * f[i - 2][j - 1] % mod + ((j - 3 * i) * qmi(j, mod - 2) % mod) * f[i][j - 1] % mod) % mod; &#125; &#125;&#125;void solve()&#123; cin &gt;&gt; (s + 1); mp.clear(); for(int i = 2; i &lt;= 26; i += 2)&#123; string s1 = &quot;&quot;; s1 += s[i - 1]; s1 += s[i]; mp[s1] ++ ; &#125; int cnt = 0; for(auto u : mp)&#123; if(u.second == 1) cnt ++ ; &#125; cout &lt;&lt; f[cnt][123];&#125;","categories":[{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"期望dp/概率dp","slug":"期望dp-概率dp","permalink":"https://hanzug.github.io/tags/%E6%9C%9F%E6%9C%9Bdp-%E6%A6%82%E7%8E%87dp/"}]},{"title":"Changign Jewels","slug":"Changign-Jewels","date":"2022-07-19T11:59:54.187Z","updated":"2022-07-19T13:59:16.802Z","comments":true,"path":"2022/07/19/Changign-Jewels/","link":"","permalink":"https://hanzug.github.io/2022/07/19/Changign-Jewels/","excerpt":"","text":"题目 大意: 开局一颗宝石，有两种操作 1.把一颗 N 级的红宝石变成一个 N - 1 级的红宝石和 X 个 N 级的蓝宝石 2.把一颗 N 级的蓝宝石变成一个 N - 1 级的蓝宝石和 Y 个 N - 1 级的红宝石 问：怎么操作使得最后得到的一级的蓝宝石最多 心情：😢 函数写法 ： 由于宝石数量开局时是唯一的， 故可以以第一个宝石为源头，每一个宝石都是一个分支，直到分成等级为1，最后判断这个一级的宝石是否为蓝色。 123456789101112131415161718int N, X, Y;#define int long longint calc(int level, bool is_red)&#123; if(level == 1) return is_red ? 0 : 1; if(is_red)&#123; return calc(level - 1, 1) + calc(level, 0) * X; &#125; else &#123; return calc(level - 1, 1) + calc(level - 1, 0) * Y; &#125;&#125;signed main()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y; cout &lt;&lt; calc(N, true) &lt;&lt; &#x27;\\n&#x27;;&#125; dp实现 ： 1234567891011int N, X, Y, r[12], b[12];void solve()&#123; cin &gt;&gt; N &gt;&gt; X &gt;&gt; Y; r[1] = 0, b[1] = 1; for(int n = 2; n &lt;= N; n ++ )&#123; b[n] = r[n - 1] + b[n - 1] * Y; r[n] = r[n - 1] + b[n] * X; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Qpwoeirut And The City","slug":"Qpwoeirut-And-The-City","date":"2022-07-19T09:48:24.715Z","updated":"2022-07-19T09:48:33.988Z","comments":true,"path":"2022/07/19/Qpwoeirut-And-The-City/","link":"","permalink":"https://hanzug.github.io/2022/07/19/Qpwoeirut-And-The-City/","excerpt":"","text":"题目 大意： 给你n栋楼，cool楼的定义为比它左右两栋的楼层都高，只可以添加楼层，不可以删减，求在建造尽可能多的cool楼的情况下添加的最少楼层。 1）如果 n 是奇数的话， 那 2 ~ n - 1 的 cool楼 一定是 高低高低…..高（1010…. 1）这样来分配才是最多的 2）如果 n 为偶数， 则又可以分情况 ​ 1.第2个建筑为高，第 n - 1 个建筑为低， 即 01010100 ​ 2.第2个建筑为低，第 n - 1 个建筑为高，即 00101010 ​ 3.基于前两种情况，我们可以在数组的中间找到一个连续两个低的位置为分界点。 ​ 即0101 00 1010 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int n;int a[N];int ans1[N], ans2[N];void solve()&#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++ )&#123; cin &gt;&gt; a[i]; &#125; for(int i = 1; i &lt;= n + 2; i ++ )&#123; ans1[i] = 0; ans2[i] = 0; &#125; int ans = 0; if(n &amp; 1)&#123; // n 为奇数 for(int i = 2; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1]) ans += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125; else &#123; ans = 2e14; for(int i = 2; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1])&#123; ans1[i] += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; if(i &gt;= 4) ans1[i] += ans1[i - 2]; &#125; for(int i = 3; i &lt;= n - 1; i += 2)&#123; if(a[i] &lt;= a[i - 1] || a[i] &lt;= a[i + 1])&#123; ans2[i] += max(a[i - 1], a[i + 1]) - a[i] + 1; &#125; if(i &gt;= 3) ans2[i] += ans2[i - 2]; &#125; for(int i = 2; i &lt;= n - 4; i += 2)&#123; ans = min(ans, ans1[i] + ans2[n - 1] - ans2[i + 2]); //注意细节，因为ans1和ans2的高分别相邻，故加和的时候只需中间差一个就凑够了两个低 &#125; ans = min(ans, min(ans1[n - 2], ans2[n - 1])); cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"Mocha and Railgun","slug":"Mocha and Railgun","date":"2022-07-18T14:16:06.690Z","updated":"2022-07-18T14:16:06.690Z","comments":true,"path":"2022/07/18/Mocha and Railgun/","link":"","permalink":"https://hanzug.github.io/2022/07/18/Mocha%20and%20Railgun/","excerpt":"","text":"题目 题目大意： 给定一个圆和严格位于圆内的一点 P Mocha 会从点 P 向任意角度发射一个长度为 2d 的电磁炮 电磁炮底边的中点为点 P 且两端位于圆内 询问单次发射能摧毁的最大圆弧长 1 ≤ T ≤ 1000*,* −109 ≤ x, y ≤ 109*,* 1 ≤ r,d ≤ 109 复习了初中知识（😀 ———————————— 知道了居然还有acos函数 12345678910double r, x, y, d;void solve()&#123; cin &gt;&gt; r; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; double res = sqrt(x * x + y * y); double t = acos(-1) - acos((d - res) / r) - acos((d + res) / r); printf(&quot;%10f\\n&quot;, t * r);&#125;","categories":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"anti-nim","slug":"未命名","date":"2022-07-18T02:16:56.753Z","updated":"2022-07-18T10:43:18.041Z","comments":true,"path":"2022/07/18/未命名/","link":"","permalink":"https://hanzug.github.io/2022/07/18/%E6%9C%AA%E5%91%BD%E5%90%8D/","excerpt":"","text":"题目 Alice 和 Bob 正在玩一个游戏，双方都很聪明。游戏是这样的，给出一个正整数 n，然后每次轮流操作，每次操作需要将数 n 除以 $2^k $。Alice 先手，谁先将数 n 变为 1 则谁输 nim游戏变形。 对 n 进行质因数分解， 每个质因子及其指数又化为取石子游戏。 auti-nim: 终止状态：最后一个取石头的人输。 . 先手必胜条件： 1.所有石子的个数为1， 且 all_xor 为0. 2.至少有一堆石子的个数大于1， 且all_xor $\\neq$ 0. $$\\Updownarrow$$ 123456789101112131415161718192021222324using ll = long long; ll n, ans; int main()&#123; cin &gt;&gt; n; bool flag = 0; for(ll i = 2; i * i &lt;= n; i ++ )&#123; if(n % i == 0)&#123; int cnt = 0; while(n % i == 0) n /= i, cnt ++ ; ans ^= cnt; if(cnt != 1) flag = 1; &#125; &#125; if(n &gt; 1) ans ^= 1; if((!flag &amp;&amp; !ans) || (flag &amp;&amp; ans)) puts(&quot;Alice win&quot;); else puts(&quot;Bob win&quot;); return 0;&#125;","categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"}]}],"categories":[{"name":"题","slug":"题","permalink":"https://hanzug.github.io/categories/%E9%A2%98/"},{"name":"笔记","slug":"笔记","permalink":"https://hanzug.github.io/categories/%E7%AC%94%E8%AE%B0/"},{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://hanzug.github.io/tags/%E6%80%9D%E7%BB%B4/"},{"name":"博弈论","slug":"博弈论","permalink":"https://hanzug.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"},{"name":"期望dp/概率dp","slug":"期望dp-概率dp","permalink":"https://hanzug.github.io/tags/%E6%9C%9F%E6%9C%9Bdp-%E6%A6%82%E7%8E%87dp/"},{"name":"搜索","slug":"搜索","permalink":"https://hanzug.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"数学","slug":"数学","permalink":"https://hanzug.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}